// Copyright (C) 1999-2007 David Sugar, Tycho Softworks.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.

/**
 * Any ucommon streaming classes that are built from std::streamio facilities
 * and that support ANSI C++ stream operators.
 * @file ucommon/stream.h
 */

#ifdef	_UCOMMON_EXTENDED_
#ifndef	_UCOMMON_STREAM_H_
#define	_UCOMMON_STREAM_H_

#ifndef	_UCOMMON_THREAD_H_
#include <ucommon/thread.h>
#endif

#ifndef	_UCOMMON_SOCKET_H_
#include <ucommon/socket.h>
#endif

#include <iostream>

NAMESPACE_UCOMMON

/**
 * Streamable tcp connection between client and server.  The tcp stream
 * class can represent a client connection to a server or an instance of
 * a service generated by a tcp listener.  As a stream class, data can 
 * be manipulated using the << and >> operators.
 *
 * @author David Sugar <dyfet@gnutelephony.org>
 * @short streamable tcp socket connection.
 */
class __EXPORT tcpstream : protected std::streambuf, protected Socket, public std::iostream
{
private:
	__LOCAL void allocate(unsigned size);

protected:
	timeout_t timeout;
	size_t bufsize;
	char *gbuf, *pbuf;

	/**
	 * Release the tcp stream and destroy the underlying socket.
	 */
	void release(void);

    /**
     * This streambuf method is used to load the input buffer
     * through the established tcp socket connection.
     *
     * @return char from get buffer, EOF if not connected.
     */
    int underflow();

    /**
     * This streambuf method is used for doing unbuffered reads
     * through the establish tcp socket connection when in interactive mode.
     * Also this method will handle proper use of buffers if not in
     * interative mode.
     *
     * @return char from tcp socket connection, EOF if not connected.
     */
    int uflow();

    /**
     * This streambuf method is used to write the output
     * buffer through the established tcp connection.
     *
     * @param ch char to push through.
     * @return char pushed through.
     */
    int overflow(int ch);

public:
	/**
	 * Create a stream from an existing tcp listener.
	 * @param listener to accept connection from.
	 * @param segsize for tcp segments and buffering.
	 * @param timeout for socket i/o operations.
	 */
	tcpstream(ListenSocket& listener, unsigned segsize = 536, timeout_t timeout = 0);

	/**
	 * Create an unconnected tcp stream object that is idle until opened.
	 * @param family of protocol to create.
	 * @param timeout for socket i/o operations.
	 */
	tcpstream(int family = PF_INET, timeout_t timeout = 0);

	/**
	 * A convenience constructor that creates a connected tcp stream directly
	 * from an address.  The socket is constructed to match the type of the
	 * the address family in the socket address that is passed.
	 * @param service to connect to.
	 * @param segsize for tcp segments and buffering.
	 * @param timeout for socket i/o operations.
	 */
	tcpstream(Socket::address *service, unsigned segsize = 536, timeout_t timeout = 0);

	/**
	 * Destroy a tcp stream.
	 */
	virtual ~tcpstream();

	/**
	 * See if stream connection is active.
	 * @return true if stream is active.
	 */
	inline operator bool()
		{return so != INVALID_SOCKET && bufsize > 0;};

	/**
	 * See if stream is disconnected.
	 * @return true if stream disconnected.
	 */
	inline bool operator!()
		{return so == INVALID_SOCKET || bufsize == 0;};

	/**
	 * Open a stream connection to a tcp service.
	 * @param address of service to access.
	 * @param buffering segment size to use.
	 */
	void open(Socket::address *address, unsigned mss = 536);

	/**
	 * Close an active stream connection.  This does not release the
	 * socket but is a disconnect.
	 */
	void close(void);

	/**
	 * Flush the stream input and output buffers, writes pending output.
	 * @return 0 on success, or error code.
	 */
	int sync(void);
};

END_NAMESPACE

#endif
#endif
